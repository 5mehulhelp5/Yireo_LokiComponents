<script>
    const LokiHtmlReplacer = {
        replace(root, incomingHTML) {
            if (!(root instanceof Element)) {
                throw new TypeError('`root` must be an Element');
            }
            if (root.hasAttribute('x-ignore')) return;

            const incomingFrag = this._parseHTML(incomingHTML);

            const existingSkips = root.querySelectorAll('[x-ignore]');
            existingSkips.forEach(oldEl => {
                const ancestor = oldEl.parentElement?.closest('[x-ignore]');
                if (ancestor && ancestor !== oldEl) return;

                const key = oldEl.getAttribute('x-ignore');
                let counterpart = null;

                if (key && key.length > 0) {
                    counterpart = incomingFrag.querySelector(`[x-ignore="${this._cssEscape(key)}"]`);
                } else {
                    const path = this._pathFromRoot(root, oldEl);
                    counterpart = this._nodeByPath(incomingFrag, path);
                    if (counterpart && !(counterpart instanceof Element && counterpart.hasAttribute('x-ignore'))) {
                        counterpart = null;
                    }
                }

                if (counterpart) {
                    counterpart.replaceWith(oldEl);
                }
            });

            root.replaceChildren(...incomingFrag.childNodes);
        },

        _parseHTML(html) {
            const tpl = document.createElement('template');
            tpl.innerHTML = String(html ?? '').trim();
            return tpl.content;
        },

        _cssEscape(ident) {
            if (window.CSS && typeof window.CSS.escape === 'function') {
                return window.CSS.escape(ident);
            }
            return String(ident)
                .replace(/[\0-\x1F\x7F]/g, '\uFFFD')
                .replace(/(^-?\d)|[^a-zA-Z0-9_\u00A0-\uFFFF-]/g, (ch, d) =>
                    d ? `\\3${d} ` : `\\${ch}`
                );
        },

        _pathFromRoot(rootEl, el) {
            const path = [];
            let cur = el;
            while (cur && cur !== rootEl) {
                const parent = cur.parentNode;
                if (!parent) break;
                let idx = 0;
                for (let sib = parent.firstElementChild; sib; sib = sib.nextElementSibling) {
                    if (sib === cur) break;
                    idx++;
                }
                path.push(idx);
                cur = parent;
            }
            path.reverse();
            return path;
        },

        _nodeByPath(rootLike, path) {
            let node = rootLike;
            for (const idx of path) {
                const children = (node instanceof DocumentFragment)
                    ? Array.from(node.children || node.childNodes).filter(n => n.nodeType === 1)
                    : node.children;
                node = children[idx];
                if (!node) return null;
            }
            return node;
        }
    };
</script>
